# Lesson 13: 深度测试总结

## 📚 目录
- [概述](#概述)
- [深度测试基础](#深度测试基础)
- [Lesson 13.1: 深度测试演示](#lesson-131-深度测试演示)
- [Lesson 13.2: 深度缓冲可视化](#lesson-132-深度缓冲可视化)
- [深度测试详解](#深度测试详解)
- [深度缓冲详解](#深度缓冲详解)
- [常见问题](#常见问题)
- [总结](#总结)

---

## 概述

Lesson 13 介绍了 **深度测试（Depth Testing）** 和 **深度缓冲（Depth Buffer）** 的概念和使用方法。本课程分为两个部分：

1. **Lesson 13.1** - 深度测试演示（可以切换启用/禁用，观察效果差异）
2. **Lesson 13.2** - 深度缓冲可视化（将深度值作为颜色显示）

### 学习目标

- ✅ 理解深度测试的概念和作用
- ✅ 掌握深度测试的工作原理
- ✅ 学会启用/禁用深度测试
- ✅ 理解深度缓冲的概念
- ✅ 学会可视化深度缓冲
- ✅ 理解深度值的范围和含义

---

## 深度测试基础

### 什么是深度测试？

**深度测试（Depth Testing）** 是 OpenGL 用来确定哪些片段应该被绘制，哪些应该被丢弃的机制。它通过比较每个片段的深度值（Z 值）来决定是否绘制该片段。

### 为什么需要深度测试？

在 3D 场景中，多个物体可能占据屏幕上的同一个像素位置。例如：
- 一个立方体在另一个立方体前面
- 一个物体遮挡另一个物体

**没有深度测试的问题**：
- 后绘制的物体会覆盖先绘制的物体
- 即使后面的物体应该被前面的物体遮挡，也会显示出来
- 渲染顺序影响最终结果（不正确）

**有深度测试的好处**：
- 正确显示物体的前后关系
- 近处的物体会遮挡远处的物体
- 渲染顺序不影响最终结果（正确）

### 深度缓冲（Depth Buffer）

**深度缓冲**（也称为 Z-Buffer）是一个存储每个像素深度值的缓冲区。

- **大小**：与颜色缓冲区相同（每个像素一个深度值）
- **格式**：通常是 24 位或 32 位浮点数
- **范围**：`[0.0, 1.0]`
  - `0.0`：最近的物体（near plane）
  - `1.0`：最远的物体（far plane）

### 深度测试的工作原理

```
对于每个片段：
1. 计算片段的深度值（Z 值）
2. 读取深度缓冲中对应位置的深度值
3. 比较两个深度值
4. 如果新片段更近（深度值更小）：
   - 绘制该片段
   - 更新深度缓冲
5. 如果新片段更远（深度值更大）：
   - 丢弃该片段（不绘制）
```

---

## Lesson 13.1: 深度测试演示

### 功能特点

- **两个立方体**：红色立方体在前，绿色立方体在后且更大
- **可切换深度测试**：按空格键切换启用/禁用
- **相机系统**：可以自由移动相机观察效果
- **实时对比**：可以立即看到有/无深度测试的区别

### 场景设置

```cpp
// 第一个立方体（红色，在 z = -1.0）
glm::mat4 model1 = glm::mat4(1.0f);
model1 = glm::translate(model1, glm::vec3(0.0f, 0.0f, -1.0f));

// 第二个立方体（绿色，在 z = -2.0，放大 1.5 倍）
glm::mat4 model2 = glm::mat4(1.0f);
model2 = glm::translate(model2, glm::vec3(0.0f, 0.0f, -2.0f));
model2 = glm::scale(model2, glm::vec3(1.5f, 1.5f, 1.5f));
```

### 关键代码

#### 启用/禁用深度测试

```cpp
// 启用深度测试
glEnable(GL_DEPTH_TEST);

// 禁用深度测试
glDisable(GL_DEPTH_TEST);
```

#### 清除深度缓冲

```cpp
// 每帧清除深度缓冲
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```

**重要**：必须同时清除颜色缓冲和深度缓冲，否则深度缓冲会保留上一帧的值。

#### 切换深度测试

```cpp
// 按空格键切换
if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
{
    m_enableDepthTest = !m_enableDepthTest;
    if (m_enableDepthTest)
        glEnable(GL_DEPTH_TEST);
    else
        glDisable(GL_DEPTH_TEST);
}
```

### 视觉效果对比

#### 启用深度测试

- ✅ **正确渲染**：红色立方体遮挡绿色立方体
- ✅ **前后关系正确**：近处的物体显示在前面
- ✅ **真实感强**：符合真实世界的视觉效果

#### 禁用深度测试

- ❌ **错误渲染**：绿色立方体覆盖红色立方体（因为后绘制）
- ❌ **前后关系错误**：远处的物体显示在前面
- ❌ **不真实**：不符合真实世界的视觉效果

### 控制说明

- **WASD**：移动相机
- **空格**：向上移动
- **Shift**：向下移动
- **鼠标移动**：旋转视角
- **滚轮**：缩放视野
- **空格键**：切换深度测试的启用/禁用
- **ESC**：退出程序

---

## Lesson 13.2: 深度缓冲可视化

### 功能特点

- **10 个立方体**：不同位置，用于观察深度变化
- **深度值可视化**：将深度值作为颜色显示
- **相机系统**：可以自由移动相机观察效果
- **灰度渐变**：白色=近处，黑色=远处

### 着色器代码

**片段着色器** (`2.depth_visualization.fs`)：
```glsl
#version 330 core
out vec4 FragColor;

void main()
{
    // 使用 gl_FragCoord.z 获取当前片段的深度值
    // 范围：[0.0, 1.0]
    // 0.0 = 最近的物体（near plane）
    // 1.0 = 最远的物体（far plane）
    float depth = gl_FragCoord.z;
    
    // 将深度值可视化：近处为白色，远处为黑色
    FragColor = vec4(vec3(depth), 1.0);
}
```

### 关键概念

#### gl_FragCoord.z

`gl_FragCoord` 是 GLSL 的内建变量，包含当前片段在窗口空间中的坐标：

```glsl
gl_FragCoord.xy  // 窗口空间坐标（像素位置）
gl_FragCoord.z   // 深度值（范围：[0.0, 1.0]）
```

**深度值的含义**：
- `0.0`：最近的物体（投影矩阵的 near plane）
- `1.0`：最远的物体（投影矩阵的 far plane）
- `0.5`：中间距离的物体

#### 深度值的非线性分布

**重要**：深度值不是线性分布的！

由于透视投影的特性，深度值在近处变化快，在远处变化慢：

```
线性分布（错误理解）：
0.0 ──────── 0.5 ──────── 1.0
near        middle        far

实际分布（非线性）：
0.0 ─── 0.1 ─── 0.2 ─── 0.3 ─── ... ─── 0.9 ─── 1.0
near    (快速变化)              (缓慢变化)    far
```

**为什么是非线性的？**

透视投影矩阵会将深度值进行非线性变换，使得：
- 近处的精度高（深度值变化快）
- 远处的精度低（深度值变化慢）

这样可以：
- 在近处提供足够的精度
- 在远处避免精度问题（Z-fighting）

### 视觉效果

- **白色区域**：距离相机近的物体（深度值接近 0.0）
- **黑色区域**：距离相机远的物体（深度值接近 1.0）
- **灰度渐变**：展示深度值的连续变化

### 控制说明

- **WASD**：移动相机
- **空格**：向上移动
- **Shift**：向下移动
- **鼠标移动**：旋转视角
- **滚轮**：缩放视野
- **ESC**：退出程序

---

## 深度测试详解

### 深度测试函数

OpenGL 提供了多种深度测试函数：

| 函数 | 说明 | 使用场景 |
|------|------|----------|
| `GL_LESS` | 新片段深度 < 缓冲深度时通过（默认） | 标准深度测试 |
| `GL_LEQUAL` | 新片段深度 ≤ 缓冲深度时通过 | 包含相等的情况 |
| `GL_GREATER` | 新片段深度 > 缓冲深度时通过 | 反向深度测试 |
| `GL_GEQUAL` | 新片段深度 ≥ 缓冲深度时通过 | 反向深度测试（包含相等） |
| `GL_EQUAL` | 新片段深度 = 缓冲深度时通过 | 精确匹配 |
| `GL_NOTEQUAL` | 新片段深度 ≠ 缓冲深度时通过 | 排除相等 |
| `GL_ALWAYS` | 总是通过 | 禁用深度测试效果 |
| `GL_NEVER` | 永远不通过 | 禁用所有绘制 |

**设置深度测试函数**：
```cpp
glDepthFunc(GL_LESS);  // 默认值
```

### 深度写入

**深度写入（Depth Writing）** 控制是否更新深度缓冲：

```cpp
// 启用深度写入（默认）
glDepthMask(GL_TRUE);

// 禁用深度写入
glDepthMask(GL_FALSE);
```

**使用场景**：
- 绘制透明物体时，可能需要禁用深度写入
- 绘制 UI 元素时，可能需要禁用深度写入

### 深度清除值

**深度清除值** 是清除深度缓冲时使用的值（默认 1.0）：

```cpp
// 设置深度清除值
glClearDepth(1.0);  // 默认值

// 清除深度缓冲
glClear(GL_DEPTH_BUFFER_BIT);
```

### 深度范围

**深度范围** 控制深度值的映射范围（默认 [0.0, 1.0]）：

```cpp
// 设置深度范围
glDepthRange(0.0, 1.0);  // 默认值
```

**注意**：通常不需要修改这个值。

### 深度测试的完整流程

```
1. 片段着色器计算片段颜色
2. 计算片段的深度值（Z 值）
3. 读取深度缓冲中对应位置的深度值
4. 执行深度测试函数（例如 GL_LESS）
5. 如果测试通过：
   a. 绘制片段（写入颜色缓冲）
   b. 更新深度缓冲（如果深度写入启用）
6. 如果测试失败：
   a. 丢弃片段（不绘制）
   b. 不更新深度缓冲
```

---

## 深度缓冲详解

### 深度缓冲的格式

深度缓冲通常使用以下格式：

| 格式 | 位数 | 精度 | 说明 |
|------|------|------|------|
| `GL_DEPTH_COMPONENT16` | 16 位 | 65536 级 | 基本精度 |
| `GL_DEPTH_COMPONENT24` | 24 位 | 16777216 级 | 标准精度（常用） |
| `GL_DEPTH_COMPONENT32` | 32 位 | 4294967296 级 | 高精度 |
| `GL_DEPTH_COMPONENT32F` | 32 位浮点 | 极高精度 | 高精度场景 |

### 深度值的计算

深度值在顶点着色器中计算，经过以下变换：

```
1. 局部空间（Local Space）
   vertex = (x, y, z, 1.0)

2. 世界空间（World Space）
   worldPos = model * vertex

3. 观察空间（View Space）
   viewPos = view * worldPos

4. 裁剪空间（Clip Space）
   clipPos = projection * viewPos
   clipPos.z / clipPos.w = 深度值（范围：[near, far]）

5. 标准化设备坐标（NDC）
   ndc.z = (clipPos.z / clipPos.w) 映射到 [-1, 1]

6. 窗口空间（Window Space）
   depth = (ndc.z + 1.0) / 2.0  // 映射到 [0.0, 1.0]
```

### 深度值的非线性

**为什么深度值是非线性的？**

透视投影矩阵使用以下公式：

```
depth = (far + near) / (far - near) - (2 * far * near) / ((far - near) * z_view)
```

这个公式导致：
- **近处**：深度值变化快（精度高）
- **远处**：深度值变化慢（精度低）

**优点**：
- 在近处提供足够的精度（避免 Z-fighting）
- 在远处避免精度浪费

**缺点**：
- 深度值不是线性分布的
- 可视化时需要注意非线性特性

### 深度缓冲的可视化方法

#### 方法 1：直接使用 gl_FragCoord.z

```glsl
float depth = gl_FragCoord.z;
FragColor = vec4(vec3(depth), 1.0);
```

**优点**：简单直接
**缺点**：非线性，近处变化快，远处变化慢

#### 方法 2：线性化深度值

```glsl
// 从非线性深度值计算线性深度值
float near = 0.1;
float far = 100.0;
float depth = gl_FragCoord.z;
float linearDepth = (2.0 * near * far) / (far + near - (2.0 * depth - 1.0) * (far - near));
FragColor = vec4(vec3(linearDepth / far), 1.0);
```

**优点**：线性分布，更直观
**缺点**：需要知道 near 和 far 值

#### 方法 3：使用深度纹理

```glsl
uniform sampler2D depthTexture;
float depth = texture(depthTexture, TexCoord).r;
FragColor = vec4(vec3(depth), 1.0);
```

**优点**：可以从纹理读取深度值
**缺点**：需要额外的纹理

---

## 常见问题

### Q1: 为什么需要清除深度缓冲？

**A:** 深度缓冲存储了上一帧的深度值。如果不清除，新帧的深度测试会与上一帧的值比较，导致错误的渲染结果。

**解决方法**：
```cpp
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```

### Q2: 深度测试和深度缓冲有什么区别？

**A:**
- **深度测试**：比较深度值的机制（过程）
- **深度缓冲**：存储深度值的数据结构（存储）

深度测试使用深度缓冲来进行比较。

### Q3: 为什么深度值是非线性的？

**A:** 这是透视投影的特性。非线性分布可以在近处提供足够的精度，在远处避免精度浪费。

**好处**：
- 近处精度高（避免 Z-fighting）
- 远处精度低（节省精度）

### Q4: 如何解决 Z-fighting 问题？

**Z-fighting** 是指两个物体非常接近时，深度值几乎相同，导致闪烁。

**解决方法**：
1. **增加深度缓冲精度**：使用 24 位或 32 位深度缓冲
2. **调整 near 和 far 值**：缩小 near 和 far 的差距
3. **使用多边形偏移**：`glPolygonOffset(factor, units)`
4. **调整物体位置**：避免物体过于接近

### Q5: 什么时候需要禁用深度测试？

**A:** 以下情况可能需要禁用深度测试：
- 绘制 2D UI 元素（总是显示在最前面）
- 绘制全屏效果（覆盖整个屏幕）
- 绘制透明物体（需要特殊处理）

### Q6: 深度写入和深度测试的区别？

**A:**
- **深度测试**：决定是否绘制片段（读取深度缓冲）
- **深度写入**：决定是否更新深度缓冲（写入深度缓冲）

可以禁用深度写入但保持深度测试：
```cpp
glEnable(GL_DEPTH_TEST);   // 启用深度测试（读取）
glDepthMask(GL_FALSE);      // 禁用深度写入（不写入）
```

### Q7: 如何可视化线性深度值？

**A:** 需要从非线性深度值计算线性深度值：

```glsl
float LinearizeDepth(float depth, float near, float far)
{
    float z = depth * 2.0 - 1.0; // 从 [0,1] 转换到 [-1,1]
    return (2.0 * near * far) / (far + near - z * (far - near));
}

void main()
{
    float depth = gl_FragCoord.z;
    float linearDepth = LinearizeDepth(depth, 0.1, 100.0);
    FragColor = vec4(vec3(linearDepth / 100.0), 1.0);
}
```

---

## 深度测试 vs 其他技术

### 深度测试 vs 画家算法

**画家算法（Painter's Algorithm）**：
- 按从远到近的顺序绘制物体
- 后绘制的物体会覆盖先绘制的物体
- **问题**：无法处理物体相交的情况

**深度测试**：
- 不需要按顺序绘制
- 自动处理物体相交
- **优点**：更灵活，更准确

### 深度测试 vs 模板测试

| 特性 | 深度测试 | 模板测试 |
|------|---------|---------|
| **用途** | 确定前后关系 | 标记特定区域 |
| **数据** | 深度值（Z 值） | 模板值（整数） |
| **精度** | 高精度（浮点数） | 低精度（整数，通常 8 位） |
| **应用** | 3D 场景渲染 | 轮廓、遮罩、选择高亮 |

### 深度测试 vs 混合

| 特性 | 深度测试 | 混合（Blending） |
|------|---------|-----------------|
| **用途** | 确定前后关系 | 混合颜色 |
| **结果** | 丢弃或保留片段 | 混合片段颜色 |
| **应用** | 不透明物体 | 透明物体 |

---

## 性能考虑

### 深度测试的性能

**深度测试的开销**：
- 每个片段都需要读取深度缓冲
- 每个片段都需要比较深度值
- 如果测试失败，可以提前丢弃片段（Early-Z）

**优化建议**：
1. **Early-Z 优化**：在片段着色器之前进行深度测试
2. **深度预传递**：先只渲染深度，再渲染颜色
3. **视锥剔除**：不渲染视锥外的物体

### 深度缓冲的精度

**精度问题**：
- 16 位深度缓冲：65536 级（可能不够）
- 24 位深度缓冲：16777216 级（通常足够）
- 32 位深度缓冲：4294967296 级（高精度场景）

**选择建议**：
- 大多数场景：24 位足够
- 高精度场景：32 位浮点

---

## 实际应用

### 游戏开发

1. **3D 场景渲染**：
   - 所有 3D 物体都需要深度测试
   - 确保正确的前后关系

2. **UI 渲染**：
   - UI 元素通常禁用深度测试
   - 或者使用特殊的深度值

3. **特效渲染**：
   - 某些特效可能需要禁用深度写入
   - 例如：粒子效果、全屏效果

### 可视化应用

1. **深度可视化**：
   - 调试深度缓冲
   - 理解场景的深度分布

2. **深度图生成**：
   - 用于阴影映射
   - 用于后处理效果

---

## 总结

### Lesson 13 的核心价值

1. **理解深度测试**：学会了深度测试的概念和作用
2. **掌握深度缓冲**：理解了深度缓冲的工作原理
3. **可视化深度**：学会了如何可视化深度值
4. **实际应用**：理解了深度测试在实际开发中的重要性

### 关键知识点

1. ✅ **深度测试**：确定片段是否应该绘制的机制
2. ✅ **深度缓冲**：存储每个像素深度值的缓冲区
3. ✅ **深度值范围**：`[0.0, 1.0]`，0.0 是最近，1.0 是最远
4. ✅ **深度值非线性**：由于透视投影，深度值不是线性分布的
5. ✅ **gl_FragCoord.z**：获取当前片段的深度值
6. ✅ **深度测试函数**：`GL_LESS`、`GL_GREATER` 等
7. ✅ **深度写入**：控制是否更新深度缓冲

### 下一步学习方向

1. **高级深度技术**：
   - 深度预传递（Depth Pre-pass）
   - 反向深度（Reversed-Z）
   - 指数深度缓冲

2. **阴影技术**：
   - 阴影映射（Shadow Mapping）
   - 软阴影（Soft Shadows）

3. **后处理效果**：
   - 景深效果（Depth of Field）
   - 雾效（Fog）

---

## 代码结构总结

```
Lesson 13
├── lesson13_1.cpp          # 深度测试演示
├── lesson13_2.cpp          # 深度缓冲可视化
├── 1.depth_testing.vs      # 深度测试顶点着色器
├── 1.depth_testing.fs      # 深度测试片段着色器
├── 2.depth_visualization.vs      # 深度可视化顶点着色器
└── 2.depth_visualization.fs      # 深度可视化片段着色器
```

---

这就是 Lesson 13 的完整总结！通过本课程，您已经掌握了深度测试和深度缓冲的核心概念，这是 3D 图形渲染的基础技术。

