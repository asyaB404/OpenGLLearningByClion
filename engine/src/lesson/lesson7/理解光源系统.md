# 理解光源系统 - Lesson 7 基础光照

## 概述

Lesson 7 引入了**基础光照系统**，这是 OpenGL 渲染中非常重要的概念。与之前的课程相比，Lesson 7 不仅仅是改变了背景颜色，而是引入了**光照模型**，让物体看起来更加真实。

## 与之前课程的区别

### Lesson 5 和 Lesson 6（无光照）

在 Lesson 5 和 Lesson 6 中：
- **物体颜色**：直接使用纹理或固定颜色
- **渲染方式**：`FragColor = texture(...)` 或 `FragColor = vec4(color, 1.0)`
- **视觉效果**：物体看起来是"平的"，没有立体感
- **背景颜色**：通常是 `(0.2, 0.3, 0.3)` - 蓝绿色

**关键代码（Lesson 5/6）：**
```glsl
// 片段着色器
void main()
{
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
    // 或者
    FragColor = vec4(1.0, 0.5, 0.31, 1.0);  // 固定颜色
}
```

### Lesson 7（基础光照）

在 Lesson 7 中：
- **物体颜色**：物体本身的颜色（objectColor）
- **光源颜色**：光源发出的颜色（lightColor）
- **最终颜色**：物体颜色 × 光源颜色
- **视觉效果**：物体有了基本的明暗效果
- **背景颜色**：`(0.1, 0.1, 0.1)` - 深灰色（更暗，突出光照效果）

**关键代码（Lesson 7）：**
```glsl
// 片段着色器
uniform vec3 objectColor;  // 物体颜色
uniform vec3 lightColor;   // 光源颜色

void main()
{
    // 最终颜色 = 物体颜色 × 光源颜色
    FragColor = vec4(lightColor * objectColor, 1.0);
}
```

## 核心概念

### 1. 物体颜色（Object Color）

物体颜色是物体**本身的颜色**，不受光照影响。例如：
- 一个红色的苹果，它的物体颜色是 `(1.0, 0.0, 0.0)` - 红色
- 一个橙色的立方体，它的物体颜色是 `(1.0, 0.5, 0.31)` - 橙色

在 Lesson 7 中：
```cpp
lightingShader.setVec3("objectColor", 1.0f, 0.5f, 0.31f);  // 橙色
```

### 2. 光源颜色（Light Color）

光源颜色是**光源发出的光的颜色**。例如：
- 白色光源：`(1.0, 1.0, 1.0)` - 所有颜色分量都是 1.0
- 红色光源：`(1.0, 0.0, 0.0)` - 只发出红光
- 蓝色光源：`(0.0, 0.0, 1.0)` - 只发出蓝光

在 Lesson 7 中：
```cpp
lightingShader.setVec3("lightColor", 1.0f, 1.0f, 1.0f);  // 白色光源
```

### 3. 最终颜色计算

**最终颜色 = 物体颜色 × 光源颜色**

这是一个**分量乘法**（Component-wise Multiplication）：
```
最终颜色 = (objectColor.r * lightColor.r, 
            objectColor.g * lightColor.g, 
            objectColor.b * lightColor.b)
```

**示例计算：**

1. **白色光源照射橙色物体：**
   ```
   物体颜色： (1.0, 0.5, 0.31)  - 橙色
   光源颜色： (1.0, 1.0, 1.0)   - 白色
   最终颜色： (1.0*1.0, 0.5*1.0, 0.31*1.0) = (1.0, 0.5, 0.31) - 橙色
   ```
   结果：物体显示为橙色（因为白色光源不改变颜色）

2. **红色光源照射橙色物体：**
   ```
   物体颜色： (1.0, 0.5, 0.31)  - 橙色
   光源颜色： (1.0, 0.0, 0.0)   - 红色
   最终颜色： (1.0*1.0, 0.5*0.0, 0.31*0.0) = (1.0, 0.0, 0.0) - 红色
   ```
   结果：物体显示为红色（因为只有红光被反射）

3. **蓝色光源照射橙色物体：**
   ```
   物体颜色： (1.0, 0.5, 0.31)  - 橙色
   光源颜色： (0.0, 0.0, 1.0)   - 蓝色
   最终颜色： (1.0*0.0, 0.5*0.0, 0.31*1.0) = (0.0, 0.0, 0.31) - 深蓝灰色
   ```
   结果：物体显示为深蓝灰色（因为橙色物体几乎不反射蓝光）

## 场景组成

### 1. 被光照的立方体（Lighted Cube）

这是场景中的**主要物体**，会被光源照亮。

**特点：**
- 使用 `lightingShader` 着色器
- 颜色由 `objectColor × lightColor` 计算
- 位置在原点 `(0, 0, 0)`
- 大小：单位立方体（边长为 1）

**代码：**
```cpp
// 使用光照着色器
lightingShader.use();
lightingShader.setVec3("objectColor", 1.0f, 0.5f, 0.31f);  // 橙色
lightingShader.setVec3("lightColor", 1.0f, 1.0f, 1.0f);   // 白色光源

// 绘制立方体
glBindVertexArray(cubeVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);
```

### 2. 光源立方体（Light Cube）

这是**光源本身的可视化表示**，用来显示光源的位置。

**特点：**
- 使用 `lightCubeShader` 着色器
- 颜色固定为白色 `(1.0, 1.0, 1.0)`
- 位置在 `lightPos = (1.2, 1.0, 2.0)`
- 大小：缩放到 0.2 倍（更小，表示光源）

**代码：**
```cpp
// 使用光源着色器
lightCubeShader.use();

// 平移到光源位置并缩小
model = glm::translate(model, lightPos);  // (1.2, 1.0, 2.0)
model = glm::scale(model, glm::vec3(0.2f));  // 缩小到 0.2 倍

// 绘制光源立方体
glBindVertexArray(lightCubeVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);
```

**为什么需要光源立方体？**
- 帮助理解光源的位置
- 可视化光源在场景中的位置
- 调试时更容易看到光源

## 为什么背景是黑色的？

背景颜色从 `(0.2, 0.3, 0.3)` 改为 `(0.1, 0.1, 0.1)` 的原因：

1. **突出光照效果**：深色背景让光照效果更明显
2. **模拟真实环境**：真实世界中，没有光照的地方通常是暗的
3. **对比度**：深色背景与亮色物体形成对比，让物体更突出

**代码：**
```cpp
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);  // 深灰色背景
```

## 光照模型详解

### 当前实现（最简单的光照模型）

Lesson 7 使用的是**最简单的光照模型**：

```
最终颜色 = 物体颜色 × 光源颜色
```

**特点：**
- ✅ 简单易懂
- ✅ 性能好
- ❌ 没有方向性（所有面都一样亮）
- ❌ 没有距离衰减（远近距离亮度相同）
- ❌ 没有阴影

### 更高级的光照模型（后续课程）

在后续课程中，会学习更复杂的光照模型：

1. **Phong 光照模型**：
   - 环境光（Ambient）
   - 漫反射（Diffuse）
   - 镜面反射（Specular）

2. **Blinn-Phong 光照模型**：
   - 改进的 Phong 模型
   - 更真实的镜面高光

3. **PBR（基于物理的渲染）**：
   - 最真实的光照模型
   - 考虑能量守恒
   - 更复杂的计算

## 代码流程

### 初始化阶段

```cpp
// 1. 创建两个着色器
Shader lightingShader(...);      // 被光照物体的着色器
Shader lightCubeShader(...);     // 光源立方体的着色器

// 2. 创建两个 VAO（共享同一个 VBO）
glGenVertexArrays(1, &cubeVAO);      // 被光照立方体
glGenVertexArrays(1, &lightCubeVAO); // 光源立方体

// 3. 设置光源位置
glm::vec3 lightPos(1.2f, 1.0f, 2.0f);
```

### 渲染阶段（每帧）

```cpp
// 1. 清除缓冲区（深灰色背景）
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

// 2. 渲染被光照的立方体
lightingShader.use();
lightingShader.setVec3("objectColor", 1.0f, 0.5f, 0.31f);
lightingShader.setVec3("lightColor", 1.0f, 1.0f, 1.0f);
// 设置变换矩阵...
glBindVertexArray(cubeVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);

// 3. 渲染光源立方体
lightCubeShader.use();
// 设置变换矩阵（平移到光源位置，缩小）...
glBindVertexArray(lightCubeVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);
```

## 关键理解

### 1. 为什么需要两个着色器？

- **lightingShader**：计算被光照物体的颜色（物体颜色 × 光源颜色）
- **lightCubeShader**：光源本身总是白色，不需要计算

### 2. 为什么需要两个 VAO？

虽然顶点数据相同，但：
- **cubeVAO**：用于被光照的立方体（在原点，不缩放）
- **lightCubeVAO**：用于光源立方体（在光源位置，缩小到 0.2 倍）

### 3. 光源位置的作用

虽然当前的光照模型很简单（没有方向性），但光源位置 `lightPos` 用于：
- 可视化光源位置（光源立方体的位置）
- 为后续课程做准备（Phong 模型需要光源位置计算方向）

## 实验建议

### 实验 1：改变光源颜色

```cpp
// 红色光源
lightingShader.setVec3("lightColor", 1.0f, 0.0f, 0.0f);

// 绿色光源
lightingShader.setVec3("lightColor", 0.0f, 1.0f, 0.0f);

// 蓝色光源
lightingShader.setVec3("lightColor", 0.0f, 0.0f, 1.0f);
```

观察物体颜色的变化！

### 实验 2：改变物体颜色

```cpp
// 红色物体
lightingShader.setVec3("objectColor", 1.0f, 0.0f, 0.0f);

// 绿色物体
lightingShader.setVec3("objectColor", 0.0f, 1.0f, 0.0f);
```

### 实验 3：改变光源位置

```cpp
glm::vec3 lightPos(0.0f, 0.0f, 0.0f);  // 光源在原点
// 或
glm::vec3 lightPos(5.0f, 5.0f, 5.0f);  // 光源在远处
```

观察光源立方体的位置变化（虽然当前模型，物体亮度不会改变）

## 总结

### Lesson 7 的核心概念

1. **物体颜色**：物体本身的颜色属性
2. **光源颜色**：光源发出的光的颜色
3. **最终颜色**：物体颜色 × 光源颜色（分量乘法）
4. **光源可视化**：用白色立方体表示光源位置

### 与之前课程的区别

| 特性 | Lesson 5/6 | Lesson 7 |
|------|-----------|----------|
| **颜色计算** | 直接使用纹理/固定颜色 | 物体颜色 × 光源颜色 |
| **光照** | 无 | 基础光照模型 |
| **背景** | 蓝绿色 `(0.2, 0.3, 0.3)` | 深灰色 `(0.1, 0.1, 0.1)` |
| **视觉效果** | 平面，无立体感 | 有基本明暗效果 |
| **着色器数量** | 1 个 | 2 个 |
| **VAO 数量** | 1 个 | 2 个 |

### 重要提示

**Lesson 7 不仅仅是改变了背景颜色！**

它引入了：
- ✅ 光照模型的概念
- ✅ 物体颜色和光源颜色的概念
- ✅ 颜色乘法的计算方式
- ✅ 光源的可视化表示

这是学习更高级光照模型（Phong、Blinn-Phong、PBR）的基础！

