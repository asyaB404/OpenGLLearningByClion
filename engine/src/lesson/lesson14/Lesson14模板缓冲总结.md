# Lesson 14: 模板缓冲总结

## 📚 目录
- [概述](#概述)
- [模板缓冲基础](#模板缓冲基础)
- [Lesson 14: 轮廓效果实现](#lesson-14-轮廓效果实现)
- [模板测试详解](#模板测试详解)
- [渲染流程详解](#渲染流程详解)
- [着色器详解](#着色器详解)
- [常见问题](#常见问题)
- [模板缓冲 vs 其他技术](#模板缓冲-vs-其他技术)
- [实际应用](#实际应用)
- [总结](#总结)

---

## 概述

Lesson 14 介绍了 **模板缓冲（Stencil Buffer）** 的概念和使用方法，通过模板缓冲实现物体轮廓高亮效果。这是游戏开发中常用的技术，可以用于：

- 物体选中高亮
- 轮廓描边效果
- 区域遮罩
- 特殊渲染效果

### 学习目标

- ✅ 理解模板缓冲的概念和作用
- ✅ 掌握模板测试的工作原理
- ✅ 学会使用模板缓冲实现轮廓效果
- ✅ 理解两遍渲染技术
- ✅ 掌握模板函数和模板操作

---

## 模板缓冲基础

### 什么是模板缓冲？

**模板缓冲（Stencil Buffer）** 是 OpenGL 的一个缓冲区，用于存储每个像素的模板值（通常是 8 位整数）。它类似于深度缓冲，但用途不同：

- **深度缓冲**：存储深度值（Z 值），用于确定前后关系
- **模板缓冲**：存储模板值（整数），用于标记特定区域

### 为什么需要模板缓冲？

模板缓冲的主要用途：

1. **区域标记**：标记屏幕上的特定区域
2. **选择性渲染**：只在特定区域渲染
3. **轮廓效果**：实现物体轮廓高亮
4. **遮罩效果**：实现区域遮罩
5. **特殊效果**：实现各种特殊渲染效果

### 模板缓冲的工作原理

```
对于每个片段：
1. 读取模板缓冲中对应位置的模板值
2. 执行模板测试函数（例如 GL_NOTEQUAL）
3. 如果测试通过：
   - 绘制该片段
   - 执行模板操作（例如 GL_REPLACE）
4. 如果测试失败：
   - 丢弃该片段（不绘制）
   - 执行模板操作（例如 GL_KEEP）
```

### 模板缓冲的格式

模板缓冲通常使用以下格式：

| 格式 | 位数 | 范围 | 说明 |
|------|------|------|------|
| `GL_STENCIL_INDEX8` | 8 位 | 0-255 | 标准格式（常用） |
| `GL_STENCIL_INDEX16` | 16 位 | 0-65535 | 高精度格式 |

**注意**：大多数情况下，8 位模板缓冲已经足够使用。

---

## Lesson 14: 轮廓效果实现

### 功能特点

- **两个立方体**：场景中有两个带纹理的立方体
- **轮廓高亮**：立方体周围有青色轮廓
- **地板**：场景中有地板作为背景
- **相机系统**：可以自由移动相机观察效果
- **三遍渲染**：使用三遍渲染技术实现轮廓效果

### 场景设置

```cpp
// 第一个立方体（在 (-1, 0, -1)）
glm::mat4 model1 = glm::mat4(1.0f);
model1 = glm::translate(model1, glm::vec3(-1.0f, 0.0f, -1.0f));

// 第二个立方体（在 (2, 0, 0)）
glm::mat4 model2 = glm::mat4(1.0f);
model2 = glm::translate(model2, glm::vec3(2.0f, 0.0f, 0.0f));
```

### 轮廓效果实现原理

轮廓效果的实现分为三个步骤：

1. **第一遍**：绘制地板（不写入模板缓冲）
2. **第二遍**：绘制立方体（写入模板缓冲，值为 1）
3. **第三遍**：绘制放大的立方体轮廓（只在模板值不等于 1 的地方绘制）

### 关键代码

#### 启用模板测试

```cpp
// 启用模板测试
glEnable(GL_STENCIL_TEST);

// 设置模板测试函数：不等于1时通过
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);

// 设置模板操作：失败时保持，通过时替换
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
```

#### 清除模板缓冲

```cpp
// 每帧清除模板缓冲
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
```

**重要**：必须同时清除颜色缓冲、深度缓冲和模板缓冲。

#### 第一遍渲染：绘制地板

```cpp
// 禁用模板写入（地板不写入模板缓冲）
glStencilMask(0x00);

m_normalShader->use();
// ... 设置矩阵和纹理 ...
glDrawArrays(GL_TRIANGLES, 0, 6);  // 绘制地板
```

#### 第二遍渲染：绘制立方体并写入模板

```cpp
// 总是通过模板测试，并写入模板值 1
glStencilFunc(GL_ALWAYS, 1, 0xFF);  // 总是通过
glStencilMask(0xFF);                // 启用模板写入

m_normalShader->use();
// ... 设置矩阵和纹理 ...
glDrawArrays(GL_TRIANGLES, 0, 36);  // 绘制第一个立方体
glDrawArrays(GL_TRIANGLES, 0, 36);  // 绘制第二个立方体
```

#### 第三遍渲染：绘制轮廓

```cpp
// 只在模板值不等于 1 的地方绘制（即轮廓区域）
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);  // 不等于1时通过
glStencilMask(0x00);                  // 禁用模板写入
glDisable(GL_DEPTH_TEST);             // 禁用深度测试（确保轮廓可见）

m_outlineShader->use();
// ... 设置矩阵 ...

// 放大 10% 绘制轮廓
float scale = 1.1f;
model = glm::scale(model, glm::vec3(scale, scale, scale));
glDrawArrays(GL_TRIANGLES, 0, 36);  // 绘制第一个立方体的轮廓
glDrawArrays(GL_TRIANGLES, 0, 36);  // 绘制第二个立方体的轮廓

// 恢复状态
glStencilMask(0xFF);
glStencilFunc(GL_ALWAYS, 0, 0xFF);
glEnable(GL_DEPTH_TEST);
```

### 视觉效果

- **立方体**：正常渲染，带纹理
- **轮廓**：青色轮廓，围绕立方体周围
- **地板**：作为背景，不受轮廓影响

### 控制说明

- **WASD**：移动相机
- **鼠标移动**：旋转视角
- **滚轮**：缩放视野
- **ESC**：退出程序

---

## 模板测试详解

### 模板测试函数

OpenGL 提供了多种模板测试函数：

| 函数 | 说明 | 使用场景 |
|------|------|----------|
| `GL_NEVER` | 永远不通过 | 禁用所有绘制 |
| `GL_ALWAYS` | 总是通过 | 总是绘制（默认） |
| `GL_LESS` | 新片段模板值 < 参考值时通过 | 小于比较 |
| `GL_LEQUAL` | 新片段模板值 ≤ 参考值时通过 | 小于等于比较 |
| `GL_GREATER` | 新片段模板值 > 参考值时通过 | 大于比较 |
| `GL_GEQUAL` | 新片段模板值 ≥ 参考值时通过 | 大于等于比较 |
| `GL_EQUAL` | 新片段模板值 = 参考值时通过 | 精确匹配 |
| `GL_NOTEQUAL` | 新片段模板值 ≠ 参考值时通过 | 排除相等（轮廓效果） |

**设置模板测试函数**：
```cpp
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
// 参数说明：
// - GL_NOTEQUAL: 测试函数
// - 1: 参考值（ref）
// - 0xFF: 掩码（mask），用于按位与操作
```

### 模板操作

**模板操作（Stencil Operation）** 控制模板缓冲的更新方式：

```cpp
glStencilOp(sfail, dpfail, dppass);
```

**参数说明**：

| 参数 | 说明 | 可能的值 |
|------|------|----------|
| `sfail` | 模板测试失败时的操作 | `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_DECR`, `GL_INVERT` |
| `dpfail` | 模板测试通过但深度测试失败时的操作 | 同上 |
| `dppass` | 模板测试和深度测试都通过时的操作 | 同上 |

**常用操作**：

| 操作 | 说明 | 使用场景 |
|------|------|----------|
| `GL_KEEP` | 保持当前模板值不变 | 默认值 |
| `GL_ZERO` | 将模板值设置为 0 | 清除标记 |
| `GL_REPLACE` | 用参考值替换模板值 | 写入标记值 |
| `GL_INCR` | 模板值加 1（如果超过最大值则保持最大值） | 计数 |
| `GL_DECR` | 模板值减 1（如果小于 0 则保持 0） | 计数 |
| `GL_INVERT` | 按位取反 | 反转标记 |

**示例**：
```cpp
// 失败时保持，通过时替换（用于写入标记）
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
```

### 模板掩码

**模板掩码（Stencil Mask）** 控制哪些位可以写入模板缓冲：

```cpp
// 启用所有位的写入
glStencilMask(0xFF);

// 禁用所有位的写入
glStencilMask(0x00);

// 只启用低 4 位的写入
glStencilMask(0x0F);
```

**使用场景**：
- 绘制物体时：`glStencilMask(0xFF)` 启用写入
- 绘制轮廓时：`glStencilMask(0x00)` 禁用写入（只读取）

### 模板清除值

**模板清除值** 是清除模板缓冲时使用的值（默认 0）：

```cpp
// 设置模板清除值
glClearStencil(0);  // 默认值

// 清除模板缓冲
glClear(GL_STENCIL_BUFFER_BIT);
```

---

## 渲染流程详解

### 完整的三遍渲染流程

#### 第一遍：绘制地板

```cpp
// 1. 禁用模板写入
glStencilMask(0x00);

// 2. 使用正常着色器
m_normalShader->use();

// 3. 绘制地板
glDrawArrays(GL_TRIANGLES, 0, 6);
```

**结果**：
- 地板被绘制到屏幕上
- 模板缓冲保持不变（因为禁用了写入）

#### 第二遍：绘制立方体并写入模板

```cpp
// 1. 设置模板测试：总是通过
glStencilFunc(GL_ALWAYS, 1, 0xFF);

// 2. 设置模板操作：通过时替换为 1
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);

// 3. 启用模板写入
glStencilMask(0xFF);

// 4. 使用正常着色器
m_normalShader->use();

// 5. 绘制立方体
glDrawArrays(GL_TRIANGLES, 0, 36);  // 第一个立方体
glDrawArrays(GL_TRIANGLES, 0, 36);  // 第二个立方体
```

**结果**：
- 立方体被绘制到屏幕上
- 立方体覆盖的区域，模板值被设置为 1
- 其他区域，模板值保持为 0

#### 第三遍：绘制轮廓

```cpp
// 1. 设置模板测试：不等于 1 时通过
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);

// 2. 禁用模板写入
glStencilMask(0x00);

// 3. 禁用深度测试（确保轮廓可见）
glDisable(GL_DEPTH_TEST);

// 4. 使用轮廓着色器（单色）
m_outlineShader->use();

// 5. 放大立方体并绘制
float scale = 1.1f;
model = glm::scale(model, glm::vec3(scale, scale, scale));
glDrawArrays(GL_TRIANGLES, 0, 36);  // 第一个立方体的轮廓
glDrawArrays(GL_TRIANGLES, 0, 36);  // 第二个立方体的轮廓

// 6. 恢复状态
glStencilMask(0xFF);
glStencilFunc(GL_ALWAYS, 0, 0xFF);
glEnable(GL_DEPTH_TEST);
```

**结果**：
- 放大的立方体被绘制，但只在模板值不等于 1 的区域绘制
- 由于立方体区域模板值为 1，所以不会绘制
- 只有轮廓区域（模板值为 0）会被绘制，形成轮廓效果

### 为什么需要禁用深度测试？

在第三遍渲染时禁用深度测试的原因：

1. **确保轮廓可见**：轮廓是放大的立方体，可能会被原始立方体遮挡
2. **避免深度冲突**：轮廓和原始立方体的深度值非常接近，可能导致 Z-fighting
3. **简化渲染**：不需要考虑深度关系，只需要考虑模板值

**注意**：禁用深度测试后，轮廓会显示在所有物体前面，这正是我们想要的效果。

---

## 着色器详解

### 正常渲染着色器

#### 顶点着色器 (`2.stencil_testing.vs`)

```glsl
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    TexCoord = aTexCoord;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
```

**功能**：
- 接收顶点位置和纹理坐标
- 应用模型、视图和投影变换
- 传递纹理坐标到片段着色器

#### 片段着色器 (`2.stencil_testing.fs`)

```glsl
#version 330 core
out vec4 FragColor;

in vec2 TexCoord;

uniform sampler2D texture1;

void main()
{
    FragColor = texture(texture1, TexCoord);
}
```

**功能**：
- 从纹理采样颜色
- 输出最终片段颜色

### 轮廓着色器

#### 顶点着色器

轮廓着色器使用与正常渲染相同的顶点着色器（`2.stencil_testing.vs`）。

#### 片段着色器 (`2.stencil_single_color.fs`)

```glsl
#version 330 core
out vec4 FragColor;

void main()
{
    // 单色输出（用于轮廓效果）
    FragColor = vec4(0.04f, 0.28f, 0.26f, 1.0f);  // 青色轮廓
}
```

**功能**：
- 输出固定的青色（RGB: 0.04, 0.28, 0.26）
- 不需要纹理采样，性能更好

**颜色说明**：
- 青色（Cyan）：RGB(0.04, 0.28, 0.26)
- 可以根据需要修改为其他颜色

---

## 常见问题

### Q1: 为什么需要三遍渲染？

**A:** 三遍渲染是实现轮廓效果的标准方法：

1. **第一遍**：绘制背景（不写入模板）
2. **第二遍**：绘制物体并写入模板标记
3. **第三遍**：绘制放大的物体，只在非标记区域绘制（形成轮廓）

这种方法可以确保轮廓只出现在物体周围，而不会覆盖物体本身。

### Q2: 为什么轮廓要放大？

**A:** 轮廓是通过绘制一个放大的物体来实现的。放大后，物体的边缘会超出原始物体的边界，形成轮廓效果。

**放大比例**：
- 通常使用 1.05 到 1.2 之间的比例
- 太小：轮廓不明显
- 太大：轮廓过粗，可能影响视觉效果

### Q3: 模板缓冲和深度缓冲有什么区别？

**A:**

| 特性 | 模板缓冲 | 深度缓冲 |
|------|---------|---------|
| **数据类型** | 整数（通常 8 位） | 浮点数（通常 24 位） |
| **用途** | 标记区域 | 确定前后关系 |
| **精度** | 低精度（0-255） | 高精度（浮点数） |
| **应用** | 轮廓、遮罩、选择 | 3D 场景渲染 |

### Q4: 如何改变轮廓颜色？

**A:** 修改轮廓片段着色器中的颜色值：

```glsl
// 红色轮廓
FragColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);

// 白色轮廓
FragColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);

// 黄色轮廓
FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);
```

### Q5: 如何实现多个物体的轮廓？

**A:** 可以为每个物体使用不同的模板值：

```cpp
// 第一个物体：模板值 1
glStencilFunc(GL_ALWAYS, 1, 0xFF);
glDrawArrays(...);  // 绘制第一个物体

// 第二个物体：模板值 2
glStencilFunc(GL_ALWAYS, 2, 0xFF);
glDrawArrays(...);  // 绘制第二个物体

// 绘制轮廓：不等于 1 且不等于 2
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
// ... 绘制第一个物体的轮廓 ...
glStencilFunc(GL_NOTEQUAL, 2, 0xFF);
// ... 绘制第二个物体的轮廓 ...
```

### Q6: 模板缓冲的性能影响？

**A:** 模板测试的性能开销很小：

- **读取开销**：每个片段读取一次模板值（非常快）
- **写入开销**：只在需要时写入模板值
- **比较开销**：简单的整数比较（非常快）

**优化建议**：
1. 只在需要时启用模板测试
2. 使用模板掩码减少不必要的写入
3. 避免频繁切换模板状态

### Q7: 如何清除模板缓冲？

**A:** 使用 `glClear()` 清除模板缓冲：

```cpp
// 清除颜色、深度和模板缓冲
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

// 只清除模板缓冲
glClear(GL_STENCIL_BUFFER_BIT);
```

### Q8: 模板测试失败时会发生什么？

**A:** 当模板测试失败时：

1. 片段被丢弃（不绘制）
2. 执行 `sfail` 或 `dpfail` 操作（取决于深度测试结果）
3. 不更新颜色缓冲和深度缓冲

---

## 模板缓冲 vs 其他技术

### 模板缓冲 vs 深度缓冲

| 特性 | 模板缓冲 | 深度缓冲 |
|------|---------|---------|
| **数据类型** | 整数（8 位） | 浮点数（24/32 位） |
| **精度** | 低（0-255） | 高（浮点数） |
| **用途** | 区域标记 | 前后关系 |
| **测试函数** | 相等/不等比较 | 大小比较 |
| **应用** | 轮廓、遮罩 | 3D 渲染 |

### 模板缓冲 vs 混合

| 特性 | 模板缓冲 | 混合（Blending） |
|------|---------|-----------------|
| **用途** | 区域标记 | 颜色混合 |
| **结果** | 丢弃或保留片段 | 混合片段颜色 |
| **精度** | 整数 | 浮点数 |
| **应用** | 轮廓、遮罩 | 透明物体 |

### 模板缓冲 vs 裁剪

| 特性 | 模板缓冲 | 裁剪（Scissor） |
|------|---------|----------------|
| **形状** | 任意形状 | 矩形 |
| **精度** | 像素级 | 像素级 |
| **性能** | 中等 | 高 |
| **应用** | 复杂遮罩 | 简单矩形遮罩 |

---

## 实际应用

### 游戏开发

1. **物体选中高亮**：
   - 玩家选中物体时显示轮廓
   - 使用模板缓冲标记选中物体
   - 绘制放大的轮廓

2. **区域标记**：
   - 标记可交互区域
   - 标记危险区域
   - 标记特殊区域

3. **特殊效果**：
   - 传送门效果
   - 魔法效果
   - UI 遮罩

### UI 开发

1. **按钮高亮**：
   - 鼠标悬停时显示轮廓
   - 使用模板缓冲标记按钮区域

2. **区域遮罩**：
   - 限制渲染区域
   - 实现圆形/不规则按钮

### 可视化应用

1. **选择高亮**：
   - 3D 模型选择
   - 场景对象选择

2. **区域标记**：
   - 标记特定区域
   - 实现区域遮罩效果

---

## 总结

### Lesson 14 的核心价值

1. **理解模板缓冲**：学会了模板缓冲的概念和作用
2. **掌握模板测试**：理解了模板测试的工作原理
3. **实现轮廓效果**：学会了使用模板缓冲实现轮廓高亮
4. **两遍渲染技术**：掌握了多遍渲染的实现方法

### 关键知识点

1. ✅ **模板缓冲**：存储每个像素模板值的缓冲区（通常 8 位）
2. ✅ **模板测试**：比较模板值决定是否绘制片段
3. ✅ **模板函数**：`GL_EQUAL`、`GL_NOTEQUAL`、`GL_ALWAYS` 等
4. ✅ **模板操作**：`GL_KEEP`、`GL_REPLACE`、`GL_INCR` 等
5. ✅ **模板掩码**：控制哪些位可以写入模板缓冲
6. ✅ **三遍渲染**：实现轮廓效果的标准方法
7. ✅ **轮廓效果**：通过放大物体并在非标记区域绘制实现

### 实现轮廓效果的步骤

1. **启用模板测试**：`glEnable(GL_STENCIL_TEST)`
2. **第一遍渲染**：绘制背景（禁用模板写入）
3. **第二遍渲染**：绘制物体并写入模板标记
4. **第三遍渲染**：绘制放大的物体，只在非标记区域绘制

### 下一步学习方向

1. **高级模板技术**：
   - 多模板值标记
   - 模板缓冲与深度缓冲结合
   - 模板缓冲优化

2. **其他轮廓技术**：
   - 法线扩展（Normal Extrusion）
   - 后处理轮廓（Post-processing Outline）
   - 几何着色器轮廓（Geometry Shader Outline）

3. **实际应用**：
   - 游戏中的选中高亮
   - UI 中的按钮高亮
   - 可视化中的区域标记

---

## 代码结构总结

```
Lesson 14
├── lesson14_1.cpp              # 模板缓冲轮廓效果实现
├── 2.stencil_testing.vs        # 正常渲染顶点着色器
├── 2.stencil_testing.fs        # 正常渲染片段着色器
└── 2.stencil_single_color.fs   # 轮廓渲染片段着色器
```

---

## 完整代码示例

### 初始化模板测试

```cpp
// 启用模板测试
glEnable(GL_STENCIL_TEST);

// 设置模板测试函数：不等于1时通过
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);

// 设置模板操作：失败时保持，通过时替换
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
```

### 三遍渲染流程

```cpp
// 清除所有缓冲
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

// ========== 第一遍：绘制地板 ==========
glStencilMask(0x00);  // 禁用模板写入
m_normalShader->use();
// ... 绘制地板 ...

// ========== 第二遍：绘制立方体并写入模板 ==========
glStencilFunc(GL_ALWAYS, 1, 0xFF);  // 总是通过
glStencilMask(0xFF);                // 启用模板写入
m_normalShader->use();
// ... 绘制立方体 ...

// ========== 第三遍：绘制轮廓 ==========
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);  // 不等于1时通过
glStencilMask(0x00);                  // 禁用模板写入
glDisable(GL_DEPTH_TEST);             // 禁用深度测试
m_outlineShader->use();
// ... 绘制放大的立方体轮廓 ...
glEnable(GL_DEPTH_TEST);              // 恢复深度测试
```

---

这就是 Lesson 14 的完整总结！通过本课程，您已经掌握了模板缓冲的核心概念和轮廓效果的实现方法，这是游戏开发和图形编程中的重要技术。
