# Lesson 5: 如何逐步渲染多个立方体

## 概述

在 Lesson 5 中，我们学习了如何使用**坐标系统**和**矩阵变换**来渲染多个立方体。虽然我们只定义了一个立方体的顶点数据，但通过不同的**模型矩阵（Model Matrix）**，我们可以在不同的位置和角度渲染多个立方体。

## 核心思想

**关键点：所有立方体共享同一个 VAO/VBO，但使用不同的模型矩阵来变换它们的位置和旋转。**

## 渲染流程详解

### 第一步：准备顶点数据

我们只定义**一个立方体**的顶点数据（36个顶点，6个面 × 每个面2个三角形 × 每个三角形3个顶点）：

```cpp
float vertices[] = {
    // 位置 (x, y, z)        // 纹理坐标 (u, v)
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
    // ... 共36个顶点
};
```

这个立方体的顶点坐标是**局部空间（Local Space）**的坐标，中心在原点 (0, 0, 0)，边长为单位长度 1。

### 第二步：定义多个立方体的世界空间位置

我们定义了10个立方体在世界空间中的位置：

```cpp
glm::vec3 cubePositions[] = {
    glm::vec3( 0.0f,  0.0f,  0.0f),  // 立方体 0：原点
    glm::vec3( 2.0f,  5.0f, -15.0f), // 立方体 1：右上后方
    glm::vec3(-1.5f, -2.2f, -2.5f),  // 立方体 2：左下前方
    // ... 共10个位置
};
```

### 第三步：创建 VAO 和 VBO

我们只创建**一个 VAO 和一个 VBO**，所有立方体共享这些数据：

```cpp
unsigned int VBO, VAO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);

glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

// 设置顶点属性
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);
```

### 第四步：设置投影矩阵和视图矩阵（每帧一次）

在渲染循环中，我们首先设置**投影矩阵**和**视图矩阵**，这两个矩阵对所有立方体都是相同的：

```cpp
// 投影矩阵：定义观察空间到裁剪空间的变换
glm::mat4 projection = glm::perspective(
    glm::radians(45.0f),                    // 视野角度
    (float)SCR_WIDTH / (float)SCR_HEIGHT,   // 宽高比
    0.1f,                                    // 近平面
    100.0f                                   // 远平面
);

// 视图矩阵：定义世界空间到观察空间的变换
// 将相机向后移动 3 个单位（沿 z 轴负方向）
glm::mat4 view = glm::mat4(1.0f);
view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));

// 将这两个矩阵传递给着色器（所有立方体共享）
ourShader.setMat4("projection", projection);
ourShader.setMat4("view", view);
```

### 第五步：循环渲染每个立方体（每帧多次）

这是**关键步骤**！我们使用一个 `for` 循环来逐个渲染每个立方体：

```cpp
glBindVertexArray(VAO);  // 绑定 VAO（所有立方体共享）
for (unsigned int i = 0; i < 10; i++)
{
    // 步骤 5.1：为每个立方体创建模型矩阵
    glm::mat4 model = glm::mat4(1.0f);  // 初始化为单位矩阵
    
    // 步骤 5.2：平移立方体到世界空间中的位置
    model = glm::translate(model, cubePositions[i]);
    
    // 步骤 5.3：旋转立方体（随时间旋转）
    float time = (float)glfwGetTime();
    float angle = 20.0f * i + time * 50.0f;  // 每个立方体有不同的角度
    model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
    
    // 步骤 5.4：将模型矩阵传递给着色器
    ourShader.setMat4("model", model);
    
    // 步骤 5.5：绘制立方体（使用相同的 VAO，但不同的模型矩阵）
    glDrawArrays(GL_TRIANGLES, 0, 36);
}
```

## 详细步骤解析

### 步骤 5.1：创建模型矩阵

```cpp
glm::mat4 model = glm::mat4(1.0f);
```

- 创建一个 4×4 的单位矩阵
- 单位矩阵表示"不做任何变换"
- 这是每个立方体的**局部空间到世界空间**的变换矩阵

### 步骤 5.2：应用平移变换

```cpp
model = glm::translate(model, cubePositions[i]);
```

- `glm::translate()` 函数在现有矩阵基础上应用平移变换
- `cubePositions[i]` 是第 i 个立方体在世界空间中的位置
- 例如：`cubePositions[1] = (2.0f, 5.0f, -15.0f)` 表示将立方体移动到 (2, 5, -15) 位置

**矩阵变换顺序很重要**：先平移，后旋转。这样旋转会围绕立方体的中心进行。

### 步骤 5.3：应用旋转变换

```cpp
float time = (float)glfwGetTime();
float angle = 20.0f * i + time * 50.0f;
model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
```

- `glfwGetTime()` 获取程序运行的时间（秒）
- `20.0f * i` 给每个立方体一个不同的初始角度（0°, 20°, 40°, ...）
- `time * 50.0f` 让立方体随时间旋转（每秒 50 度）
- `glm::rotate()` 在现有矩阵基础上应用旋转变换
- 旋转轴是 `(1.0f, 0.3f, 0.5f)`，这是一个归一化的向量

### 步骤 5.4：传递模型矩阵到着色器

```cpp
ourShader.setMat4("model", model);
```

- 将计算好的模型矩阵传递给着色器的 `model` uniform 变量
- 着色器会使用这个矩阵来变换顶点位置

### 步骤 5.5：绘制立方体

```cpp
glDrawArrays(GL_TRIANGLES, 0, 36);
```

- 使用相同的 VAO（包含立方体的顶点数据）
- 但由于模型矩阵不同，每个立方体会被绘制在不同的位置和角度
- `0` 是起始索引，`36` 是要绘制的顶点数量（一个立方体有 36 个顶点）

## 坐标系统变换流程

每个立方体的顶点在着色器中经历以下变换：

```
局部空间 (Local Space)
    ↓ [模型矩阵 Model Matrix]
世界空间 (World Space)      ← 每个立方体有不同的模型矩阵
    ↓ [视图矩阵 View Matrix]
观察空间 (View Space)      ← 所有立方体共享同一个视图矩阵
    ↓ [投影矩阵 Projection Matrix]
裁剪空间 (Clip Space)      ← 所有立方体共享同一个投影矩阵
    ↓ [透视除法]
标准化设备坐标 (NDC)
    ↓ [视口变换]
屏幕空间 (Screen Space)
```

在顶点着色器中：

```glsl
gl_Position = projection * view * model * vec4(aPos, 1.0);
```

矩阵乘法的顺序是：**从右到左**应用变换。

## 为什么只用一个 VAO？

**优势：**
1. **内存效率**：不需要为每个立方体存储重复的顶点数据
2. **性能优化**：顶点数据只需要上传到 GPU 一次
3. **代码简洁**：只需要管理一个 VAO/VBO

**原理：**
- VAO/VBO 存储的是**局部空间**的顶点数据
- 通过不同的**模型矩阵**，我们可以将同一个局部空间的立方体变换到不同的世界空间位置
- OpenGL 在绘制时会自动应用当前设置的模型矩阵

## 渲染循环的完整流程

每一帧的渲染流程：

```
1. 清除颜色缓冲和深度缓冲
   ↓
2. 绑定纹理
   ↓
3. 激活着色器程序
   ↓
4. 设置投影矩阵和视图矩阵（所有立方体共享）
   ↓
5. 绑定 VAO（所有立方体共享）
   ↓
6. 循环 10 次：
   ├─ 计算第 i 个立方体的模型矩阵
   ├─ 将模型矩阵传递给着色器
   └─ 绘制立方体（glDrawArrays）
   ↓
7. 交换缓冲区
```

## 关键代码片段

### 完整的渲染循环

```cpp
while (!glfwWindowShouldClose(window))
{
    // 清除缓冲
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    // 绑定纹理
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture1);
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, texture2);
    
    // 使用着色器
    ourShader.use();
    
    // 设置投影和视图矩阵（每帧一次，所有立方体共享）
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), 
                                            (float)SCR_WIDTH / (float)SCR_HEIGHT, 
                                            0.1f, 100.0f);
    glm::mat4 view = glm::mat4(1.0f);
    view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
    ourShader.setMat4("projection", projection);
    ourShader.setMat4("view", view);
    
    // 绑定 VAO（所有立方体共享）
    glBindVertexArray(VAO);
    
    // 循环渲染每个立方体
    for (unsigned int i = 0; i < 10; i++)
    {
        // 为每个立方体计算不同的模型矩阵
        glm::mat4 model = glm::mat4(1.0f);
        model = glm::translate(model, cubePositions[i]);
        
        float time = (float)glfwGetTime();
        float angle = 20.0f * i + time * 50.0f;
        model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
        
        // 更新模型矩阵并绘制
        ourShader.setMat4("model", model);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    }
    
    // 交换缓冲区
    glfwSwapBuffers(window);
    glfwPollEvents();
}
```

## 总结

Lesson 5 展示了如何高效地渲染多个相同几何体的实例：

1. **共享顶点数据**：所有立方体使用同一个 VAO/VBO
2. **不同的变换矩阵**：每个立方体使用不同的模型矩阵
3. **循环渲染**：在循环中逐个计算模型矩阵并绘制
4. **矩阵变换顺序**：先平移，后旋转（在模型矩阵中）
5. **矩阵应用顺序**：Model → View → Projection（在着色器中）

这种方法是 OpenGL 中渲染多个相同物体的**标准做法**，既高效又灵活。

