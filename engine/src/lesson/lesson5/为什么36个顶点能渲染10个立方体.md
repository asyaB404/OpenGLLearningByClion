# 为什么 36 个顶点能渲染出 10 个立方体？

## 核心问题

很多初学者会困惑：明明只定义了 **36 个顶点**（一个立方体），为什么能渲染出 **10 个立方体**？

答案是：**这 36 个顶点是"模板"，通过不同的模型矩阵，它们被变换到不同的位置，从而渲染出多个立方体。**

## 关键理解

### 1. 顶点数据是"局部空间"的坐标

我们定义的 36 个顶点是**局部空间（Local Space）**的坐标：

```cpp
float vertices[] = {
    // 这是一个立方体的顶点，中心在原点 (0, 0, 0)
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,  // 左下后
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,  // 右下后
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,  // 右上后
    // ... 共 36 个顶点
};
```

这 36 个顶点定义了一个**标准的立方体模板**：
- 中心在原点 (0, 0, 0)
- 边长为 1
- 这是立方体的"局部坐标系"

### 2. 模型矩阵将局部空间变换到世界空间

在顶点着色器中，每个顶点都会经过模型矩阵的变换：

```glsl
// 顶点着色器
uniform mat4 model;        // 模型矩阵
uniform mat4 view;         // 视图矩阵
uniform mat4 projection;   // 投影矩阵

void main()
{
    // 关键：模型矩阵将局部空间的顶点变换到世界空间
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    //                                    ↑
    //                              这里应用模型矩阵
}
```

**模型矩阵的作用：**
- 将局部空间的顶点坐标变换到世界空间
- 通过平移、旋转、缩放，可以让同一个立方体出现在不同的位置

### 3. 每次绘制前更新模型矩阵

在渲染循环中，我们为每个立方体设置不同的模型矩阵：

```cpp
for (unsigned int i = 0; i < 10; i++)
{
    // 步骤 1：创建模型矩阵（初始为单位矩阵）
    glm::mat4 model = glm::mat4(1.0f);
    
    // 步骤 2：应用平移变换（将立方体移动到不同位置）
    model = glm::translate(model, cubePositions[i]);
    // 例如：cubePositions[0] = (0, 0, 0)
    //      cubePositions[1] = (2, 5, -15)
    //      cubePositions[2] = (-1.5, -2.2, -2.5)
    
    // 步骤 3：应用旋转变换（让立方体旋转）
    float angle = 20.0f * i + time * 50.0f;
    model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
    
    // 步骤 4：将模型矩阵传递给着色器
    ourShader.setMat4("model", model);
    // 此时，着色器中的 model uniform 变量被更新了
    
    // 步骤 5：绘制立方体
    glDrawArrays(GL_TRIANGLES, 0, 36);
    // 这 36 个顶点会被当前的 model 矩阵变换
}
```

## 详细执行流程

让我们追踪一个具体的例子：渲染第 2 个立方体（i = 1）

### 初始状态

```cpp
// VAO 中存储的顶点数据（局部空间）
顶点 0: (-0.5, -0.5, -0.5)  // 立方体的左下后角
顶点 1: ( 0.5, -0.5, -0.5)  // 立方体的右下后角
顶点 2: ( 0.5,  0.5, -0.5)  // 立方体的右上后角
// ... 共 36 个顶点
```

### 步骤 1：创建模型矩阵

```cpp
glm::mat4 model = glm::mat4(1.0f);
// model = [1, 0, 0, 0]
//         [0, 1, 0, 0]
//         [0, 0, 1, 0]
//         [0, 0, 0, 1]  (单位矩阵，不做任何变换)
```

### 步骤 2：应用平移

```cpp
model = glm::translate(model, cubePositions[1]);  // (2, 5, -15)
// 现在 model 矩阵会将顶点平移到 (2, 5, -15) 位置
```

**变换效果：**
- 顶点 0: (-0.5, -0.5, -0.5) → (1.5, 4.5, -15.5)
- 顶点 1: ( 0.5, -0.5, -0.5) → (2.5, 4.5, -15.5)
- 顶点 2: ( 0.5,  0.5, -0.5) → (2.5, 5.5, -15.5)
- ... 所有 36 个顶点都被平移到新位置

### 步骤 3：应用旋转

```cpp
float angle = 20.0f * 1 + time * 50.0f;  // 假设 time = 1.0，angle = 70°
model = glm::rotate(model, glm::radians(70.0f), glm::vec3(1.0f, 0.3f, 0.5f));
// 现在 model 矩阵会先平移，再旋转
```

**变换效果：**
- 立方体被平移到 (2, 5, -15)
- 然后围绕轴 (1, 0.3, 0.5) 旋转 70 度

### 步骤 4：传递到着色器

```cpp
ourShader.setMat4("model", model);
// 着色器中的 uniform mat4 model 变量现在包含了完整的变换矩阵
```

### 步骤 5：绘制

```cpp
glDrawArrays(GL_TRIANGLES, 0, 36);
```

**OpenGL 执行过程：**

1. **读取顶点数据**：从 VAO 中读取 36 个顶点（局部空间坐标）
2. **应用模型矩阵**：对每个顶点执行 `model * vertex`
   ```
   对于顶点 0: (-0.5, -0.5, -0.5)
   → 应用 model 矩阵
   → 得到世界空间坐标: (约 1.5, 4.5, -15.5) 并旋转
   ```
3. **应用视图矩阵**：`view * (model * vertex)`
4. **应用投影矩阵**：`projection * view * model * vertex`
5. **光栅化**：将变换后的顶点绘制到屏幕上

### 步骤 6：循环继续

```cpp
// 下一次循环 (i = 2)
model = glm::mat4(1.0f);  // 重置为单位矩阵
model = glm::translate(model, cubePositions[2]);  // (-1.5, -2.2, -2.5)
// ... 同样的 36 个顶点，但被变换到不同的位置
glDrawArrays(GL_TRIANGLES, 0, 36);
// 又绘制了一个立方体，但位置不同
```

## 可视化理解

### 时间线：渲染 10 个立方体的过程

```
帧开始
  ↓
清除缓冲区
  ↓
绑定 VAO（包含 36 个顶点的局部坐标）
  ↓
设置投影矩阵（所有立方体共享）
  ↓
设置视图矩阵（所有立方体共享）
  ↓
┌─────────────────────────────────────┐
│ 循环开始：i = 0                      │
│  1. 创建模型矩阵（单位矩阵）          │
│  2. 平移：cubePositions[0] = (0,0,0) │
│  3. 旋转：angle = 0° + time*50°      │
│  4. 传递模型矩阵到着色器             │
│  5. glDrawArrays(0, 36)              │
│     → 36 个顶点被变换并绘制          │
│     → 屏幕上出现第 1 个立方体        │
└─────────────────────────────────────┘
  ↓
┌─────────────────────────────────────┐
│ 循环继续：i = 1                      │
│  1. 创建模型矩阵（单位矩阵）          │
│  2. 平移：cubePositions[1] = (2,5,-15)│
│  3. 旋转：angle = 20° + time*50°     │
│  4. 传递模型矩阵到着色器             │
│  5. glDrawArrays(0, 36)              │
│     → 同样的 36 个顶点，但被变换到   │
│        不同位置，并旋转不同角度       │
│     → 屏幕上出现第 2 个立方体        │
└─────────────────────────────────────┘
  ↓
... (继续循环，i = 2 到 9)
  ↓
┌─────────────────────────────────────┐
│ 循环结束：i = 9                      │
│  → 屏幕上出现第 10 个立方体         │
└─────────────────────────────────────┘
  ↓
交换缓冲区
  ↓
帧结束
```

## 关键概念：顶点数据 vs 变换矩阵

### 顶点数据（VAO/VBO）

```cpp
// 存储在 GPU 内存中（只存储一次）
float vertices[36 * 5] = {
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,  // 顶点 0
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,  // 顶点 1
    // ... 共 36 个顶点
};
```

**特点：**
- ✅ 只定义一次
- ✅ 存储在 GPU 内存中
- ✅ 所有立方体共享这 36 个顶点
- ✅ 这是立方体的"模板"或"原型"

### 变换矩阵（Uniform 变量）

```cpp
// 每次绘制前更新（存储在 GPU 的 uniform 存储区）
glm::mat4 model = glm::mat4(1.0f);
model = glm::translate(model, cubePositions[i]);
model = glm::rotate(model, angle, axis);
ourShader.setMat4("model", model);  // 更新 uniform 变量
```

**特点：**
- ✅ 每次绘制前更新
- ✅ 存储在 GPU 的 uniform 存储区
- ✅ 每个立方体使用不同的模型矩阵
- ✅ 这是立方体的"位置和姿态"

## 类比理解

### 类比 1：印章和纸张

想象一下：
- **36 个顶点** = 一个印章（模板）
- **模型矩阵** = 印章盖在不同位置和角度
- **10 个立方体** = 在 10 个不同位置盖了 10 次印章

```
印章（36个顶点）: [立方体模板]
  ↓
位置 1 + 角度 1 → 立方体 1
位置 2 + 角度 2 → 立方体 2
位置 3 + 角度 3 → 立方体 3
...
位置 10 + 角度 10 → 立方体 10
```

### 类比 2：演员和舞台

- **36 个顶点** = 一个演员（角色）
- **模型矩阵** = 演员在舞台上的不同位置和朝向
- **10 个立方体** = 同一个演员在舞台上表演 10 次，每次在不同的位置

## 代码执行细节

### 第一次绘制（i = 0）

```cpp
// 1. 创建模型矩阵
glm::mat4 model = glm::mat4(1.0f);
// model = 单位矩阵

// 2. 平移
model = glm::translate(model, glm::vec3(0.0f, 0.0f, 0.0f));
// model 现在会将顶点平移到 (0, 0, 0)

// 3. 旋转
float angle = 20.0f * 0 + time * 50.0f;  // 假设 time = 1.0，angle = 50°
model = glm::rotate(model, glm::radians(50.0f), glm::vec3(1.0f, 0.3f, 0.5f));

// 4. 传递到着色器
ourShader.setMat4("model", model);
// 着色器中的 model uniform 现在包含：先平移到 (0,0,0)，再旋转 50°

// 5. 绘制
glDrawArrays(GL_TRIANGLES, 0, 36);
// OpenGL 执行：
//   - 读取 36 个顶点（局部空间）
//   - 对每个顶点：worldPos = model * localPos
//   - 顶点 0: (-0.5, -0.5, -0.5) → 变换后 → 绘制
//   - 顶点 1: ( 0.5, -0.5, -0.5) → 变换后 → 绘制
//   - ... 共 36 个顶点
//   - 结果：屏幕上出现一个立方体，位置在 (0, 0, 0)，旋转 50°
```

### 第二次绘制（i = 1）

```cpp
// 1. 创建模型矩阵（重新开始）
glm::mat4 model = glm::mat4(1.0f);
// model = 单位矩阵（重置了！）

// 2. 平移（不同的位置）
model = glm::translate(model, glm::vec3(2.0f, 5.0f, -15.0f));
// model 现在会将顶点平移到 (2, 5, -15)

// 3. 旋转（不同的角度）
float angle = 20.0f * 1 + time * 50.0f;  // 假设 time = 1.0，angle = 70°
model = glm::rotate(model, glm::radians(70.0f), glm::vec3(1.0f, 0.3f, 0.5f));

// 4. 传递到着色器（更新了 uniform 变量）
ourShader.setMat4("model", model);
// 着色器中的 model uniform 现在包含：先平移到 (2,5,-15)，再旋转 70°

// 5. 绘制（使用相同的 36 个顶点！）
glDrawArrays(GL_TRIANGLES, 0, 36);
// OpenGL 执行：
//   - 读取同样的 36 个顶点（局部空间）
//   - 对每个顶点：worldPos = model * localPos（但 model 不同了！）
//   - 顶点 0: (-0.5, -0.5, -0.5) → 变换后 → 绘制（位置不同了）
//   - 顶点 1: ( 0.5, -0.5, -0.5) → 变换后 → 绘制（位置不同了）
//   - ... 共 36 个顶点
//   - 结果：屏幕上出现另一个立方体，位置在 (2, 5, -15)，旋转 70°
```

## 关键点总结

### 1. 顶点数据是"模板"

```cpp
// 这 36 个顶点定义了一个"标准立方体模板"
// 中心在原点，边长为 1
float vertices[36 * 5] = { /* ... */ };
```

### 2. 模型矩阵是"变换"

```cpp
// 每个立方体使用不同的模型矩阵
// 模型矩阵 = 平移 + 旋转
glm::mat4 model = glm::translate(glm::mat4(1.0f), position);
model = glm::rotate(model, angle, axis);
```

### 3. 着色器执行变换

```glsl
// 在 GPU 上，对每个顶点执行：
gl_Position = projection * view * model * vec4(aPos, 1.0);
//                                    ↑
//                              这里将局部空间变换到世界空间
```

### 4. 每次绘制使用不同的模型矩阵

```cpp
for (int i = 0; i < 10; i++) {
    // 更新模型矩阵
    model = calculateModelMatrix(i);
    ourShader.setMat4("model", model);
    
    // 绘制（使用相同的顶点数据，但不同的变换）
    glDrawArrays(GL_TRIANGLES, 0, 36);
}
```

## 内存和性能

### 内存使用

```
单个 VAO/VBO 方式：
- 顶点数据：36 个顶点 × 5 个 float × 4 字节 = 720 字节
- 模型矩阵：10 个立方体 × 16 个 float × 4 字节 = 640 字节（uniform 变量）
- 总计：约 1.36 KB

如果为每个立方体创建 VAO/VBO：
- 顶点数据：10 × 720 字节 = 7.2 KB
- 总计：约 7.2 KB

节省：约 5.84 KB（对于 10 个立方体）
```

### 性能优势

1. **减少内存传输**：顶点数据只上传到 GPU 一次
2. **减少状态切换**：不需要切换 VAO
3. **GPU 缓存友好**：顶点数据在 GPU 缓存中，可以重复使用

## 常见误解

### ❌ 误解 1：需要 360 个顶点（36 × 10）

**错误理解：** 需要为每个立方体定义 36 个顶点，总共 360 个顶点。

**正确理解：** 只需要 36 个顶点作为模板，通过不同的模型矩阵变换到不同位置。

### ❌ 误解 2：每次绘制会修改顶点数据

**错误理解：** `glDrawArrays` 会修改 VAO 中的顶点数据。

**正确理解：** `glDrawArrays` **不会**修改顶点数据。它只是读取顶点数据，应用当前的 uniform 变量（模型矩阵），然后绘制。

### ❌ 误解 3：需要 10 个 VAO

**错误理解：** 每个立方体需要一个 VAO。

**正确理解：** 所有立方体共享一个 VAO，但使用不同的模型矩阵。

## 总结

**为什么 36 个顶点能渲染 10 个立方体？**

1. **36 个顶点是模板**：定义了一个标准立方体的局部空间坐标
2. **模型矩阵是变换**：将局部空间的顶点变换到世界空间的不同位置
3. **每次绘制前更新模型矩阵**：让同一个模板出现在不同位置
4. **GPU 自动应用变换**：在顶点着色器中，每个顶点都会被当前的模型矩阵变换
5. **结果**：同一个模板被绘制 10 次，每次在不同的位置和角度

**核心原理：**
```
局部空间顶点（36个，存储在VAO中）
    ↓ [应用模型矩阵 1]
世界空间位置 1 → 绘制 → 立方体 1

局部空间顶点（同样的36个）
    ↓ [应用模型矩阵 2]
世界空间位置 2 → 绘制 → 立方体 2

... 重复 10 次
```

这就是为什么只需要 36 个顶点，却能渲染出 10 个立方体的原因！

