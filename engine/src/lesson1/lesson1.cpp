// ============================================================================
// 头文件包含
// ============================================================================
#include <iostream>        // 标准输入输出库，用于 cout、endl 等
#include <glad/glad.h>     // GLAD：OpenGL 函数加载器，必须在 GLFW 之前包含
#include <GLFW/glfw3.h>    // GLFW：窗口和输入管理库
#include "../common/common.h"  // 公共工具函数（回调函数和输入处理）

using namespace std;

// ============================================================================
// 全局常量定义
// ============================================================================
// 定义窗口的宽度和高度（单位：像素）
const unsigned int SCR_WIDTH = 800;   // 窗口宽度：800 像素
const unsigned int SCR_HEIGHT = 600;  // 窗口高度：600 像素

// ============================================================================
// Lesson 1: 创建窗口和基本渲染循环
// ============================================================================
int lesson1_main() {
    // ========================================================================
    // 第一步：初始化 GLFW（窗口管理库）
    // ========================================================================
    // glfwInit: 初始化 GLFW 库，必须在其他 GLFW 函数之前调用
    glfwInit();
    
    // ========================================================================
    // 第二步：配置 GLFW 窗口属性（在创建窗口之前设置）
    // ========================================================================
    // glfwWindowHint: 设置窗口创建时的各种属性
    
    // 设置 OpenGL 主版本号为 3（OpenGL 3.x）
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    
    // 设置 OpenGL 次版本号为 3（OpenGL 3.3）
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    
    // 设置使用核心配置文件（Core Profile）
    // Core Profile: 只包含现代 OpenGL 功能，不包含已弃用的旧功能
    // 这是现代 OpenGL 开发的标准做法
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    // macOS 特殊设置：必须启用前向兼容
    // 原因：macOS 只支持 Core Profile + Forward Compatible 模式
    // 如果不设置这个，在 macOS 上创建窗口会失败
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    // ========================================================================
    // 第三步：创建窗口
    // ========================================================================
    // glfwCreateWindow: 创建窗口和 OpenGL 上下文
    // 参数：
    //   - SCR_WIDTH, SCR_HEIGHT: 窗口的宽度和高度
    //   - "OpenGL Learning - Lesson 1": 窗口标题
    //   - nullptr, nullptr: 全屏模式和资源共享（这里不使用）
    // 返回值：窗口指针，如果创建失败返回 nullptr
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "OpenGL Learning - Lesson 1", nullptr, nullptr);
    
    // 检查窗口是否创建成功
    if (window == nullptr) {
        cout << "Failed to create GLFW window" << endl;
        glfwTerminate();  // 清理 GLFW 资源
        return -1;         // 返回错误码
    }
    
    // 将当前窗口的 OpenGL 上下文设置为当前线程的主上下文
    // 这样后续的 OpenGL 调用就会作用在这个窗口上
    glfwMakeContextCurrent(window);
    
    // 注册窗口大小改变的回调函数
    // 当窗口大小改变时，会自动调用 framebuffer_size_callback 函数
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // ========================================================================
    // 第四步：初始化 GLAD（OpenGL 函数加载器）
    // ========================================================================
    // GLAD 的作用：加载 OpenGL 函数的实际地址
    // 因为 OpenGL 是跨平台的，函数地址在运行时才能确定
    // glfwGetProcAddress: GLFW 提供的函数，用于获取 OpenGL 函数的地址
    // gladLoadGLLoader: GLAD 提供的函数，用于加载所有 OpenGL 函数
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        cout << "Failed to initialize GLAD" << endl;
        return -1;  // 初始化失败，退出程序
    }

    // ========================================================================
    // 第五步：设置 OpenGL 视口（渲染区域）
    // ========================================================================
    // glViewport: 告诉 OpenGL 渲染窗口的哪一部分
    // 参数：(x, y, width, height)
    //   - (0, 0): 从窗口左下角开始（OpenGL 使用左下角为原点）
    //   - SCR_WIDTH, SCR_HEIGHT: 渲染整个窗口
    // 注意：如果窗口大小改变，这个函数会在回调函数中再次调用
    glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);

    // ========================================================================
    // 第六步：渲染循环（游戏循环）
    // ========================================================================
    // 这个循环会一直运行，直到窗口被关闭
    // glfwWindowShouldClose: 检查窗口是否应该关闭
    //   - 返回 false: 继续循环
    //   - 返回 true: 退出循环（比如用户按了 ESC 键）
    while (!glfwWindowShouldClose(window)) {
        // ----------------------------------------------------------------
        // 6.1 处理输入
        // ----------------------------------------------------------------
        // 检查用户的键盘、鼠标输入
        // 例如：检查是否按了 ESC 键
        processInput(window);

        // ----------------------------------------------------------------
        // 6.2 渲染指令（绘制画面）
        // ----------------------------------------------------------------
        // glClearColor: 设置清屏时使用的颜色（RGBA 格式）
        // 参数：(R, G, B, A)
        //   - 0.2f, 0.3f, 0.3f: RGB 颜色值（0.0-1.0），深青色
        //   - 1.0f: Alpha 透明度（1.0 = 完全不透明）
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        
        // glClear: 清空指定的缓冲区
        // GL_COLOR_BUFFER_BIT: 清空颜色缓冲区（就是清屏）
        // 这会把整个窗口填充为上面设置的颜色（深青色）
        glClear(GL_COLOR_BUFFER_BIT);

        // ----------------------------------------------------------------
        // 6.3 交换缓冲区和处理事件
        // ----------------------------------------------------------------
        // glfwSwapBuffers: 交换前后缓冲区
        // 解释：
        //   - 双缓冲机制：有两个缓冲区（前缓冲区和后缓冲区）
        //   - 我们在后缓冲区绘制画面
        //   - 绘制完成后，交换两个缓冲区，用户就能看到新画面
        //   - 这样可以避免画面闪烁
        glfwSwapBuffers(window);
        
        // glfwPollEvents: 处理窗口事件
        // 例如：窗口大小改变、鼠标移动、键盘输入等
        // 必须每帧调用，否则窗口会无响应
        glfwPollEvents();
    }

    // ========================================================================
    // 第七步：清理资源
    // ========================================================================
    // glfwTerminate: 清理所有 GLFW 资源
    // 包括：关闭窗口、释放内存等
    // 这是良好的编程习惯，确保资源被正确释放
    glfwTerminate();
    
    // 程序正常退出
    return 0;
}

